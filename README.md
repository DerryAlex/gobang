# GOBANG

## 规则

有禁手。每步15秒。

## 使用指南

### TUI

在非UTF8环境下可能出现乱码。输入坐标下棋，比如h8或H8. 输入q或Q调用AI. 输入w或W悔棋。 输入r或R显示本局棋谱。 输入p或P来Pass. 

### GUI

需要GTK4. 点击即可。右侧上面的图标是悔棋，下面的图标是调用AI. 

## AI实现

### 局面评估

对于一个位置的好坏产生影响的主要是“米”字形范围。
```
x   x   x
 x  x  x
  x x x
   xxx
xxxx@xxxx
   xxx
  x x x
 x  x  x
x   x   x
```
可以根据“米”字形范围的情况来快速判断棋形：五连和长连是容易判断的，然后按照定义，活四是有两个成五点（注意黑、白棋要分开判断，白棋成长连也可以），冲四是有一个成五点，活三是再走一步可以成活四，眠三是再走一步可以成冲四……对每种棋形赋分，简单的把四个方向的分数相加。然后为四四、四三、三三等特殊棋形再加上一定的分数。（可改进：连活三和跳活三等可以赋不同的分）

基于这个想法，每次落子之后只需要更新“米”字形范围内点的评估值。

我们需要经常进行这个操作，所以有必要优化其效率。可以把一个方向上情况压成二进制位，这样情况不会太多(3^9)，可以用数组查询。然后再把四个方向综合考虑的结果存进一个数组，情况也不会太多(8^4)，就可以较快地处理这一操作。

**注意** 这样会把假禁手判断为禁手，禁手的判断需要递归处理（参考裁判程序）。此外，这样会忽视“米”字型之外的联系。
```
○┼┼┼┼
┼●○┼▲
┼┼●○●
┼┼┼●┼
┼┼┼┼┼
```
例如，三角形标注的位置也是很有价值的，因为在右下角形成了一个四三点，可以逼迫对方，同时这个点也可能和其他部分联系起来，但按照上面的方法只会评估出来三角形的位置形成了活二。

对于整体的局面评估，可以考虑棋盘上空白点的“潜能”之和。问题是容易看出的，即一步可能会使造成分值较大的改变。（由于五子棋容易“攻崩”，好的评估函数并不容易找到）

### min-max搜索

现在，有了局面评估之后，就可以看成双方都尽可能使自己的分值大，而使对方的分值小。*假设双方都足够聪明，并且评估函数非常合理*。只看一步效果肯定是不好的，如果现在看N步，那么我们肯定要选择一个N步之后分值最大的，而我们操作之后，对方肯定要选择一个（对我们来说）(N-1)步之后分值最小的……以N=2为例，假如现在我们有两个操作A和B，A操作之后的得分是60,B操作之后的得分是50,那么60和50有用吗？没有，因为我们要看N步。然后A操作之后，对方有C操作和D操作，C操作之后的得分是20,D操作之后的得分是10,那么对方当然会选D操作，于是A操作的看2步得分是10；而B操作之后，对方有E操作和F操作，E操作之后的得分是30,F操作之后的得分是40,那么B操作的看2步得分是40。N>2的情形是类似的，得到N步的得分，反推(N-1)步的得分，再反推(N-2)步的得分……

#### alpha-beta剪枝

如果某一个策略已经判断出来比另一个策略差，就不必继续搜索这个策略的剩余分支了。这是没有副作用的。

#### 启发式搜索

先搜索估值高的分支。这也是没有副作用的。

#### 迭代加深搜索

先尝试看K步，如果时间充足，尝试看K+1步。搜索树是指数增长的，浪费的时间不会太多。

#### 一个稍显激进的剪枝

```
xxxxx
xxxxx
xx@xx
xxxxx
xxxxx
```
如果以一个位置为中心5x5范围内没有其他棋子，那么可以认为它毫无价值。副作用较小。

#### 一个激进的剪枝

每一层只考虑单步评估较高的若干个分支。有副作用。

### VCF & VCT

连续冲四活三。

VCF考虑进攻五连、防御五连、进攻活四、进攻冲四。

VCT考虑进攻五连、防御五连、进攻活四、进攻冲四、防御活四和四四（至少需要考虑“米”字型范围，不能只考虑活四点），接下来就比较难办了，是进攻还是防守呢？（因为活四、四四是必胜，四三、冲四则未必）如果对面有冲四，直接截断是一种办法，这样应该不会犯错，但效果肯定会差一些；另一种就是忽视，继续算杀，进攻活三，这样可能会出问题。

可改进：可以在min-max搜索深度较浅的偶数层调用VCF/VCT来判断是否对方算杀（可能需要把时间限制得严一些）。

### 置换表

[默认禁用]不同的路径到达相同的局面会重复搜索，这浪费了不少的时间。如果把搜索过的局面的部分信息存储下来的话，就可以加速程序，不过这也会使得程序的结果变得不稳定（由于置换表冲突）。

## 其他

然后四个方向的操作有的时候是四段几乎一样的代码，这样不太好，但是可以少做几次比较，还是提倡写成下面的形式。

```c
void process_xxx(int x0, int y0, int dx, int dy)
{
	for (int i = 1; i <= 4; i++) operation_xxx(x0 + i * dx, y0 + i * dy);
}
```

## 致谢

参考了[https://www.xqbase.com/computer.htm](https://www.xqbase.com/computer.htm)（国际象棋）

感谢cyh同学以及jy同学为本程序测试做出了一定贡献，并与我交流了一些想法。

`ai.svg`和`undo.svg`实际上是`Adwaita`主题的`dialog-question-symbolic.svg`和`edit-undo-symbolic-rtl.svg`。
